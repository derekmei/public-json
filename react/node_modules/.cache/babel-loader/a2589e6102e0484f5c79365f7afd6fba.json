{"ast":null,"code":"d3 = require('d3');\n\nclass TreeChart {\n  constructor() {\n    // Exposed variables\n    const attrs = {\n      id: `ID${Math.floor(Math.random() * 1000000)}`,\n      // Id for event handlings\n      svgWidth: 800,\n      svgHeight: 600,\n      marginTop: 0,\n      marginBottom: 0,\n      marginRight: 0,\n      marginLeft: 0,\n      container: 'body',\n      defaultTextFill: '#2C3E50',\n      nodeTextFill: 'white',\n      defaultFont: 'Helvetica',\n      backgroundColor: '#fafafa',\n      data: null,\n      depth: 180,\n      duration: 600,\n      strokeWidth: 3,\n      dropShadowId: null,\n      initialZoom: 1,\n      onNodeClick: d => d\n    };\n\n    this.getChartState = () => attrs; // Dynamically set getter and setter functions for Chart class\n\n\n    Object.keys(attrs).forEach(key => {\n      //@ts-ignore\n      this[key] = function (_) {\n        if (!arguments.length) {\n          return attrs[key];\n        } else {\n          attrs[key] = _;\n        }\n\n        return this;\n      };\n    });\n    this.initializeEnterExitUpdatePattern();\n  }\n\n  initializeEnterExitUpdatePattern() {\n    d3.selection.prototype.patternify = function (params) {\n      var container = this;\n      var selector = params.selector;\n      var elementTag = params.tag;\n      var data = params.data || [selector]; // Pattern in action\n\n      var selection = container.selectAll('.' + selector).data(data, (d, i) => {\n        if (typeof d === 'object') {\n          if (d.id) {\n            return d.id;\n          }\n        }\n\n        return i;\n      });\n      selection.exit().remove();\n      selection = selection.enter().append(elementTag).merge(selection);\n      selection.attr('class', selector);\n      return selection;\n    };\n  } // This method retrieves passed node's children IDs (including node)      \n\n\n  getNodeChildrenIds({\n    data,\n    children,\n    _children\n  }, nodeIdsStore) {\n    // Store current node ID\n    nodeIdsStore.push(data.nodeId); // Loop over children and recursively store descendants id (expanded nodes)\n\n    if (children) {\n      children.forEach(d => {\n        this.getNodeChildrenIds(d, nodeIdsStore);\n      });\n    } // Loop over _children and recursively store descendants id (collapsed nodes)\n\n\n    if (_children) {\n      _children.forEach(d => {\n        this.getNodeChildrenIds(d, nodeIdsStore);\n      });\n    } // Return result\n\n\n    return nodeIdsStore;\n  } // This method can be invoked via chart.setZoomFactor API, it zooms to particulat scale\n\n\n  setZoomFactor(zoomLevel) {\n    const attrs = this.getChartState();\n    const calc = attrs.calc; // Store passed zoom level\n\n    attrs.initialZoom = zoomLevel; // Rescale container element accordingly\n\n    attrs.centerG.attr('transform', ` translate(${calc.centerX}, ${calc.nodeMaxHeight / 2}) scale(${attrs.initialZoom})`);\n  }\n\n  render() {\n    //InnerFunctions which will update visuals\n    const attrs = this.getChartState();\n    const thisObjRef = this; //Drawing containers\n\n    const container = d3.select(attrs.container);\n    const containerRect = container.node().getBoundingClientRect();\n    if (containerRect.width > 0) attrs.svgWidth = containerRect.width; //Attach drop shadow id to attrs object\n\n    this.setDropShadowId(attrs); //Calculated properties\n\n    const calc = {\n      id: null,\n      chartTopMargin: null,\n      chartLeftMargin: null,\n      chartWidth: null,\n      chartHeight: null\n    };\n    calc.id = `ID${Math.floor(Math.random() * 1000000)}`; // id for event handlings\n\n    calc.chartLeftMargin = attrs.marginLeft;\n    calc.chartTopMargin = attrs.marginTop;\n    calc.chartWidth = attrs.svgWidth - attrs.marginRight - calc.chartLeftMargin;\n    calc.chartHeight = attrs.svgHeight - attrs.marginBottom - calc.chartTopMargin;\n    attrs.calc = calc; // Get maximum node width and height\n\n    calc.nodeMaxWidth = d3.max(attrs.data, ({\n      width\n    }) => width);\n    calc.nodeMaxHeight = d3.max(attrs.data, ({\n      height\n    }) => height); // Calculate max node depth (it's needed for layout heights calculation)\n\n    attrs.depth = calc.nodeMaxHeight + 100;\n    calc.centerX = calc.chartWidth / 2; //********************  LAYOUTS  ***********************\n\n    const layouts = {\n      treemap: null\n    };\n    attrs.layouts = layouts; // Generate tree layout function\n\n    layouts.treemap = d3.tree().size([calc.chartWidth, calc.chartHeight]).nodeSize([calc.nodeMaxWidth + 100, calc.nodeMaxHeight + attrs.depth]); // ******************* BEHAVIORS . **********************\n\n    const behaviors = {\n      zoom: null\n    }; // Get zooming function \n\n    behaviors.zoom = d3.zoom().on(\"zoom\", d => this.zoomed(d)); //****************** ROOT node work ************************\n    // Convert flat data to hierarchical\n\n    attrs.root = d3.stratify().id(({\n      nodeId\n    }) => nodeId).parentId(({\n      parentNodeId\n    }) => parentNodeId)(attrs.data); // Set child nodes enter appearance positions\n\n    attrs.root.x0 = 0;\n    attrs.root.y0 = 0;\n    /** Get all nodes as array (with extended parent & children properties set)\n        This way we can access any node's parent directly using node.parent - pretty cool, huh?\n    */\n\n    attrs.allNodes = attrs.layouts.treemap(attrs.root).descendants(); // Assign direct children and total subordinate children's cound\n\n    attrs.allNodes.forEach(d => {\n      Object.assign(d.data, {\n        directSubordinates: d.children ? d.children.length : 0,\n        totalSubordinates: d.descendants().length - 1\n      });\n    });\n    const children = attrs.root.children;\n\n    if (children) {\n      // Collapse all children at first\n      children.forEach(d => this.collapse(d)); // Then expand some nodes, which have `expanded` property set\n\n      children.forEach(d => this.expandSomeNodes(d));\n    } // *************************  DRAWING **************************\n    //Add svg\n\n\n    const svg = container.patternify({\n      tag: 'svg',\n      selector: 'svg-chart-container'\n    }).attr('width', attrs.svgWidth).attr('height', attrs.svgHeight).attr('font-family', attrs.defaultFont).call(behaviors.zoom).attr('cursor', 'move').style('background-color', attrs.backgroundColor);\n    attrs.svg = svg; //Add container g element\n\n    const chart = svg.patternify({\n      tag: 'g',\n      selector: 'chart'\n    }).attr('transform', `translate(${calc.chartLeftMargin},${calc.chartTopMargin})`); // Add one more container g element, for better positioning controls\n\n    attrs.centerG = chart.patternify({\n      tag: 'g',\n      selector: 'center-group'\n    }).attr('transform', `translate(${calc.centerX},${calc.nodeMaxHeight / 2}) scale(${attrs.initialZoom})`);\n    attrs.chart = chart; // ************************** ROUNDED AND SHADOW IMAGE  WORK USING SVG FILTERS **********************\n    //Adding defs element for rounded image\n\n    attrs.defs = svg.patternify({\n      tag: 'defs',\n      selector: 'image-defs'\n    }); // Adding defs element for image's shadow\n\n    const filterDefs = svg.patternify({\n      tag: 'defs',\n      selector: 'filter-defs'\n    }); // Adding shadow element - (play with svg filter here - https://bit.ly/2HwnfyL)\n\n    const filter = filterDefs.patternify({\n      tag: 'filter',\n      selector: 'shadow-filter-element'\n    }).attr('id', attrs.dropShadowId).attr('y', `${-50}%`).attr('x', `${-50}%`).attr('height', `${200}%`).attr('width', `${200}%`); // Add gaussian blur element for shadows - we can control shadow length with this\n\n    filter.patternify({\n      tag: 'feGaussianBlur',\n      selector: 'feGaussianBlur-element'\n    }).attr('in', 'SourceAlpha').attr('stdDeviation', 3.1).attr('result', 'blur'); // Add fe-offset element for shadows -  we can control shadow positions with it\n\n    filter.patternify({\n      tag: 'feOffset',\n      selector: 'feOffset-element'\n    }).attr('in', 'blur').attr('result', 'offsetBlur').attr(\"dx\", 4.28).attr(\"dy\", 4.48).attr(\"x\", 8).attr(\"y\", 8); // Add fe-flood element for shadows - we can control shadow color and opacity with this element\n\n    filter.patternify({\n      tag: 'feFlood',\n      selector: 'feFlood-element'\n    }).attr(\"in\", \"offsetBlur\").attr(\"flood-color\", 'black').attr(\"flood-opacity\", 0.3).attr(\"result\", \"offsetColor\"); // Add feComposite element for shadows\n\n    filter.patternify({\n      tag: 'feComposite',\n      selector: 'feComposite-element'\n    }).attr(\"in\", \"offsetColor\").attr(\"in2\", \"offsetBlur\").attr(\"operator\", \"in\").attr(\"result\", \"offsetBlur\"); // Add feMerge element for shadows\n\n    const feMerge = filter.patternify({\n      tag: 'feMerge',\n      selector: 'feMerge-element'\n    }); // Add feMergeNode element for shadows\n\n    feMerge.patternify({\n      tag: 'feMergeNode',\n      selector: 'feMergeNode-blur'\n    }).attr('in', 'offsetBlur'); // Add another feMergeNode element for shadows\n\n    feMerge.patternify({\n      tag: 'feMergeNode',\n      selector: 'feMergeNode-graphic'\n    }).attr('in', 'SourceGraphic'); // Display tree contenrs\n\n    this.update(attrs.root); //#########################################  UTIL FUNCS ##################################\n    // This function restyles foreign object elements ()\n\n    d3.select(window).on(`resize.${attrs.id}`, () => {\n      const containerRect = container.node().getBoundingClientRect(); //  if (containerRect.width > 0) attrs.svgWidth = containerRect.width;\n      //\tmain();\n    });\n    return this;\n  } // This function sets drop shadow ID to the passed object\n\n\n  setDropShadowId(d) {\n    // If it's already set, then return \n    if (d.dropShadowId) return; // Generate drop shadow ID\n\n    let id = `${d.id}-drop-shadow`; // If DOM object is available, then use UID method to generated shadow id\n    //@ts-ignore\n\n    if (typeof DOM != 'undefined') {\n      //@ts-ignore\n      id = DOM.uid(d.id).id;\n    } // Extend passed object with drop shadow ID\n\n\n    Object.assign(d, {\n      dropShadowId: id\n    });\n  } // This function can be invoked via chart.addNode API, and it adds node in tree at runtime\n\n\n  addNode(obj) {\n    const attrs = this.getChartState();\n    attrs.data.push(obj); // Update state of nodes and redraw graph\n\n    this.updateNodesState();\n    return this;\n  } // This function can be invoked via chart.removeNode API, and it removes node from tree at runtime\n\n\n  removeNode(nodeId) {\n    const attrs = this.getChartState();\n    const node = attrs.allNodes.filter(({\n      data\n    }) => data.nodeId == nodeId)[0]; // Remove all node childs\n\n    if (node) {\n      // Retrieve all children nodes ids (including current node itself)\n      const nodeChildrenIds = this.getNodeChildrenIds(node, []); // Filter out retrieved nodes and reassign data\n\n      attrs.data = attrs.data.filter(d => !nodeChildrenIds.includes(d.nodeId));\n      const updateNodesState = this.updateNodesState.bind(this); // Update state of nodes and redraw graph\n\n      updateNodesState();\n    }\n  } // This function basically redraws visible graph, based on nodes state\n\n\n  update({\n    x0,\n    y0,\n    x,\n    y\n  }) {\n    const attrs = this.getChartState();\n    const calc = attrs.calc; //  Assigns the x and y position for the nodes\n\n    const treeData = attrs.layouts.treemap(attrs.root); // Get tree nodes and links and attach some properties \n\n    const nodes = treeData.descendants().map(d => {\n      // If at least one property is already set, then we don't want to reset other properties\n      if (d.width) return d; // Declare properties with deffault values\n\n      let imageWidth = 100;\n      let imageHeight = 100;\n      let imageBorderColor = 'steelblue';\n      let imageBorderWidth = 0;\n      let imageRx = 0;\n      let imageCenterTopDistance = 0;\n      let imageCenterLeftDistance = 0;\n      let borderColor = 'steelblue';\n      let backgroundColor = 'steelblue';\n      let width = d.data.width;\n      let height = d.data.height;\n      let dropShadowId = `none`; // Override default values based on data\n\n      if (d.data.nodeImage && d.data.nodeImage.shadow) {\n        dropShadowId = `url(#${attrs.dropShadowId})`;\n      }\n\n      if (d.data.nodeImage && d.data.nodeImage.width) {\n        imageWidth = d.data.nodeImage.width;\n      }\n\n      ;\n\n      if (d.data.nodeImage && d.data.nodeImage.height) {\n        imageHeight = d.data.nodeImage.height;\n      }\n\n      ;\n\n      if (d.data.nodeImage && d.data.nodeImage.borderColor) {\n        imageBorderColor = this.rgbaObjToColor(d.data.nodeImage.borderColor);\n      }\n\n      ;\n\n      if (d.data.nodeImage && d.data.nodeImage.borderWidth) {\n        imageBorderWidth = d.data.nodeImage.borderWidth;\n      }\n\n      ;\n\n      if (d.data.nodeImage && d.data.nodeImage.centerTopDistance) {\n        imageCenterTopDistance = d.data.nodeImage.centerTopDistance;\n      }\n\n      ;\n\n      if (d.data.nodeImage && d.data.nodeImage.centerLeftDistance) {\n        imageCenterLeftDistance = d.data.nodeImage.centerLeftDistance;\n      }\n\n      ;\n\n      if (d.data.borderColor) {\n        borderColor = this.rgbaObjToColor(d.data.borderColor);\n      }\n\n      if (d.data.backgroundColor) {\n        backgroundColor = this.rgbaObjToColor(d.data.backgroundColor);\n      }\n\n      if (d.data.nodeImage && d.data.nodeImage.cornerShape.toLowerCase() == \"circle\") {\n        imageRx = Math.max(imageWidth, imageHeight);\n      }\n\n      if (d.data.nodeImage && d.data.nodeImage.cornerShape.toLowerCase() == \"rounded\") {\n        imageRx = Math.min(imageWidth, imageHeight) / 6;\n      } // Extend node object with calculated properties\n\n\n      return Object.assign(d, {\n        imageWidth,\n        imageHeight,\n        imageBorderColor,\n        imageBorderWidth,\n        borderColor,\n        backgroundColor,\n        imageRx,\n        width,\n        height,\n        imageCenterTopDistance,\n        imageCenterLeftDistance,\n        dropShadowId\n      });\n    }); // Get all links\n\n    const links = treeData.descendants().slice(1); // Set constant depth for each nodes\n\n    nodes.forEach(d => d.y = d.depth * attrs.depth); // ------------------- FILTERS ---------------------\n    // Add patterns for each node (it's needed for rounded image implementation)\n\n    const patternsSelection = attrs.defs.selectAll('.pattern').data(nodes, ({\n      id\n    }) => id); // Define patterns enter selection\n\n    const patternEnterSelection = patternsSelection.enter().append('pattern'); // Patters update selection\n\n    const patterns = patternEnterSelection.merge(patternsSelection).attr('class', 'pattern').attr('height', 1).attr('width', 1).attr('id', ({\n      id\n    }) => id); // Add images to patterns\n\n    const patternImages = patterns.patternify({\n      tag: 'image',\n      selector: 'pattern-image',\n      data: d => [d]\n    }).attr('x', 0).attr('y', 0).attr('height', ({\n      imageWidth\n    }) => imageWidth).attr('width', ({\n      imageHeight\n    }) => imageHeight).attr('xlink:href', ({\n      data\n    }) => data.nodeImage && data.nodeImage.url).attr('viewbox', ({\n      imageWidth,\n      imageHeight\n    }) => `0 0 ${imageWidth * 2} ${imageHeight}`).attr('preserveAspectRatio', 'xMidYMin slice'); // Remove patterns exit selection after animation\n\n    patternsSelection.exit().transition().duration(attrs.duration).remove(); // --------------------------  LINKS ----------------------\n    // Get links selection\n\n    const linkSelection = attrs.centerG.selectAll('path.link').data(links, ({\n      id\n    }) => id); // Enter any new links at the parent's previous position.\n\n    const linkEnter = linkSelection.enter().insert('path', \"g\").attr(\"class\", \"link\").attr('d', d => {\n      const o = {\n        x: x0,\n        y: y0\n      };\n      return this.diagonal(o, o);\n    }); // Get links update selection\n\n    const linkUpdate = linkEnter.merge(linkSelection); // Styling links\n\n    linkUpdate.attr(\"fill\", \"none\").attr(\"stroke-width\", ({\n      data\n    }) => data.connectorLineWidth || 2).attr('stroke', ({\n      data\n    }) => {\n      if (data.connectorLineColor) {\n        return this.rgbaObjToColor(data.connectorLineColor);\n      }\n\n      return 'green';\n    }).attr('stroke-dasharray', ({\n      data\n    }) => {\n      if (data.dashArray) {\n        return data.dashArray;\n      }\n\n      return '';\n    }); // Transition back to the parent element position\n\n    linkUpdate.transition().duration(attrs.duration).attr('d', d => this.diagonal(d, d.parent)); // Remove any  links which is exiting after animation\n\n    const linkExit = linkSelection.exit().transition().duration(attrs.duration).attr('d', d => {\n      const o = {\n        x: x,\n        y: y\n      };\n      return this.diagonal(o, o);\n    }).remove(); // --------------------------  NODES ----------------------\n    // Get nodes selection\n\n    const nodesSelection = attrs.centerG.selectAll('g.node').data(nodes, ({\n      id\n    }) => id); // Enter any new nodes at the parent's previous position.\n\n    const nodeEnter = nodesSelection.enter().append('g').attr('class', 'node').attr(\"transform\", d => `translate(${x0},${y0})`).attr('cursor', 'pointer').on('click', ({\n      data\n    }) => {\n      if ([...d3.event.srcElement.classList].includes('node-button-circle')) {\n        return;\n      }\n\n      attrs.onNodeClick(data.nodeId);\n    }); // Add background rectangle for the nodes \n\n    nodeEnter.patternify({\n      tag: 'rect',\n      selector: 'node-rect',\n      data: d => [d]\n    }).style(\"fill\", ({\n      _children\n    }) => _children ? \"lightsteelblue\" : \"#fff\");\n    /*\n    // Add node icon image inside node\n    nodeEnter\n        .patternify({\n            tag: 'image',\n            selector: 'node-icon-image',\n            data: d => [d]\n        })\n        .attr('width', ({\n            data\n        }) => data.nodeIcon && data.nodeIcon.size)\n        .attr('height', ({\n            data\n        }) => data.nodeIcon && data.nodeIcon.size)\n        .attr(\"xlink:href\", ({\n            data\n        }) => data.nodeIcon && data.nodeIcon.icon)\n        .attr('x', ({\n            width\n        }) => -width / 2 + 5)\n        .attr('y', ({\n            height,\n            data\n        }) => height / 2 - (data.nodeIcon && data.nodeIcon.size || 0) - 5)\n     // Add total descendants text\n    nodeEnter\n        .patternify({\n            tag: 'text',\n            selector: 'node-icon-text-total',\n            data: d => [d]\n        })\n        .text('test')\n        .attr('x', ({\n            width\n        }) => -width / 2 + 7)\n        .attr('y', ({\n            height,\n            data\n        }) => height / 2 -  (data.nodeIcon && data.nodeIcon.size) - 5)\n        .text(({\n            data\n        }) => `${data.totalSubordinates} Subordinates`)\n        .attr('fill', attrs.nodeTextFill)\n        .attr('font-weight', 'bold')\n     // Add direct descendants text\n    nodeEnter\n        .patternify({\n            tag: 'text',\n            selector: 'node-icon-text-direct',\n            data: d => [d]\n        })\n        .text('test')\n        .attr('x', ({\n            width,\n            data\n        }) => -width / 2 + 10 + (data.nodeIcon && data.nodeIcon.size))\n        .attr('y', ({\n            height\n        }) => height / 2 - 10)\n        .text(({\n            data\n        }) => `${data.directSubordinates} Direct `)\n        .attr('fill', attrs.nodeTextFill)\n        .attr('font-weight', 'bold')\n      */\n    // Defined node images wrapper group\n\n    const nodeImageGroups = nodeEnter.patternify({\n      tag: 'g',\n      selector: 'node-image-group',\n      data: d => [d]\n    }); // Add background rectangle for node image\n\n    nodeImageGroups.patternify({\n      tag: 'rect',\n      selector: 'node-image-rect',\n      data: d => [d]\n    }); // Node update styles\n\n    const nodeUpdate = nodeEnter.merge(nodesSelection).style('font', '12px sans-serif'); // Add foreignObject element inside rectangle\n\n    const fo = nodeUpdate.patternify({\n      tag: 'foreignObject',\n      selector: 'node-foreign-object',\n      data: d => [d]\n    }); // Add foreign object \n\n    fo.patternify({\n      tag: 'xhtml:div',\n      selector: 'node-foreign-object-div',\n      data: d => [d]\n    });\n    this.restyleForeignObjectElements(); // Add Node button circle's group (expand-collapse button)\n\n    const nodeButtonGroups = nodeEnter.patternify({\n      tag: 'g',\n      selector: 'node-button-g',\n      data: d => [d]\n    }).on('click', d => this.onButtonClick(d)); // Add expand collapse button circle \n\n    nodeButtonGroups.patternify({\n      tag: 'circle',\n      selector: 'node-button-circle',\n      data: d => [d]\n    }); // Add button text \n\n    nodeButtonGroups.patternify({\n      tag: 'text',\n      selector: 'node-button-text',\n      data: d => [d]\n    }).attr('pointer-events', 'none'); // Transition to the proper position for the node\n\n    nodeUpdate.transition().attr('opacity', 0).duration(attrs.duration).attr(\"transform\", ({\n      x,\n      y\n    }) => `translate(${x},${y})`).attr('opacity', 1); // Move images to desired positions\n\n    nodeUpdate.selectAll('.node-image-group').attr('transform', ({\n      imageWidth,\n      width,\n      imageHeight,\n      height\n    }) => {\n      let x = -imageWidth / 2 - width / 2;\n      let y = -imageHeight / 2 - height / 2;\n      return `translate(${x},${y})`;\n    }); // Style node image rectangles\n\n    nodeUpdate.select('.node-image-rect').attr('fill', ({\n      id\n    }) => `url(#${id})`).attr('width', ({\n      imageWidth\n    }) => imageWidth).attr('height', ({\n      imageHeight\n    }) => imageHeight).attr('stroke', ({\n      imageBorderColor\n    }) => imageBorderColor).attr('stroke-width', ({\n      imageBorderWidth\n    }) => imageBorderWidth).attr('rx', ({\n      imageRx\n    }) => imageRx).attr('y', ({\n      imageCenterTopDistance\n    }) => imageCenterTopDistance).attr('x', ({\n      imageCenterLeftDistance\n    }) => imageCenterLeftDistance).attr('filter', ({\n      dropShadowId\n    }) => dropShadowId); // Style node rectangles\n\n    nodeUpdate.select('.node-rect').attr('width', ({\n      data\n    }) => data.width).attr('height', ({\n      data\n    }) => data.height).attr('x', ({\n      data\n    }) => -data.width / 2).attr('y', ({\n      data\n    }) => -data.height / 2).attr('rx', ({\n      data\n    }) => data.borderRadius || 0).attr('stroke-width', ({\n      data\n    }) => data.borderWidth || attrs.strokeWidth).attr('cursor', 'pointer').attr('stroke', ({\n      borderColor\n    }) => borderColor).style(\"fill\", ({\n      backgroundColor\n    }) => backgroundColor); // Move node button group to the desired position\n\n    nodeUpdate.select('.node-button-g').attr('transform', ({\n      data\n    }) => `translate(0,${data.height / 2})`).attr('opacity', ({\n      children,\n      _children\n    }) => {\n      if (children || _children) {\n        return 1;\n      }\n\n      return 0;\n    }); // Restyle node button circle\n\n    nodeUpdate.select('.node-button-circle').attr('r', 16).attr('stroke-width', ({\n      data\n    }) => data.borderWidth || attrs.strokeWidth).attr('fill', attrs.backgroundColor).attr('stroke', ({\n      borderColor\n    }) => borderColor); // Restyle button texts\n\n    nodeUpdate.select('.node-button-text').attr('text-anchor', 'middle').attr('alignment-baseline', 'middle').attr('fill', attrs.defaultTextFill).attr('font-size', ({\n      children\n    }) => {\n      if (children) return 40;\n      return 26;\n    }).text(({\n      children\n    }) => {\n      if (children) return '-';\n      return '+';\n    }).attr('y', this.isEdge() ? 10 : 0); // Remove any exiting nodes after transition\n\n    const nodeExitTransition = nodesSelection.exit().attr('opacity', 1).transition().duration(attrs.duration).attr(\"transform\", d => `translate(${x},${y})`).on('end', function () {\n      d3.select(this).remove();\n    }).attr('opacity', 0); // On exit reduce the node rects size to 0\n\n    nodeExitTransition.selectAll('.node-rect').attr('width', 10).attr('height', 10).attr('x', 0).attr('y', 0); // On exit reduce the node image rects size to 0\n\n    nodeExitTransition.selectAll('.node-image-rect').attr('width', 10).attr('height', 10).attr('x', ({\n      width\n    }) => width / 2).attr('y', ({\n      height\n    }) => height / 2); // Store the old positions for transition.\n\n    nodes.forEach(d => {\n      d.x0 = d.x;\n      d.y0 = d.y;\n    });\n  } // This function detects whether current browser is edge\n\n\n  isEdge() {\n    return window.navigator.userAgent.includes(\"Edge\");\n  }\n  /* Function converts rgba objects to rgba color string \n    {red:110,green:150,blue:255,alpha:1}  => rgba(110,150,255,1)\n  */\n\n\n  rgbaObjToColor({\n    red,\n    green,\n    blue,\n    alpha\n  }) {\n    return `rgba(${red},${green},${blue},${alpha})`;\n  } // Generate custom diagonal - play with it here - https://observablehq.com/@bumbeishvili/curved-edges?collection=@bumbeishvili/work-components\n\n\n  diagonal(s, t) {\n    // Calculate some variables based on source and target (s,t) coordinates\n    const x = s.x;\n    const y = s.y;\n    const ex = t.x;\n    const ey = t.y;\n    let xrvs = ex - x < 0 ? -1 : 1;\n    let yrvs = ey - y < 0 ? -1 : 1;\n    let rdef = 35;\n    let rInitial = Math.abs(ex - x) / 2 < rdef ? Math.abs(ex - x) / 2 : rdef;\n    let r = Math.abs(ey - y) / 2 < rInitial ? Math.abs(ey - y) / 2 : rInitial;\n    let h = Math.abs(ey - y) / 2 - r;\n    let w = Math.abs(ex - x) - r * 2; // Build the path\n\n    const path = `\n             M ${x} ${y}\n             L ${x} ${y + h * yrvs}\n             C  ${x} ${y + h * yrvs + r * yrvs} ${x} ${y + h * yrvs + r * yrvs} ${x + r * xrvs} ${y + h * yrvs + r * yrvs}\n             L ${x + w * xrvs + r * xrvs} ${y + h * yrvs + r * yrvs}\n             C ${ex}  ${y + h * yrvs + r * yrvs} ${ex}  ${y + h * yrvs + r * yrvs} ${ex} ${ey - h * yrvs}\n             L ${ex} ${ey}\n           `; // Return result\n\n    return path;\n  }\n\n  restyleForeignObjectElements() {\n    const attrs = this.getChartState();\n    attrs.svg.selectAll('.node-foreign-object').attr('width', ({\n      width\n    }) => width).attr('height', ({\n      height\n    }) => height).attr('x', ({\n      width\n    }) => -width / 2).attr('y', ({\n      height\n    }) => -height / 2);\n    attrs.svg.selectAll('.node-foreign-object-div').style('width', ({\n      width\n    }) => `${width}px`).style('height', ({\n      height\n    }) => `${height}px`).style('color', 'white').html(({\n      data\n    }) => data.template);\n  } // Toggle children on click.\n\n\n  onButtonClick(d) {\n    // If childrens are expanded\n    if (d.children) {\n      //Collapse them\n      d._children = d.children;\n      d.children = null; // Set descendants expanded property to false\n\n      this.setExpansionFlagToChildren(d, false);\n    } else {\n      // Expand children\n      d.children = d._children;\n      d._children = null; // Set each children as expanded\n\n      d.children.forEach(({\n        data\n      }) => data.expanded = true);\n    } // Redraw Graph \n\n\n    this.update(d);\n  } // This function changes `expanded` property to descendants\n\n\n  setExpansionFlagToChildren({\n    data,\n    children,\n    _children\n  }, flag) {\n    // Set flag to the current property\n    data.expanded = flag; // Loop over and recursively update expanded children's descendants\n\n    if (children) {\n      children.forEach(d => {\n        this.setExpansionFlagToChildren(d, flag);\n      });\n    } // Loop over and recursively update collapsed children's descendants\n\n\n    if (_children) {\n      _children.forEach(d => {\n        this.setExpansionFlagToChildren(d, flag);\n      });\n    }\n  } // This function can be invoked via chart.setExpanded API, it expands or collapses particular node\n\n\n  setExpanded(id, expandedFlag) {\n    const attrs = this.getChartState(); // Retrieve node by node Id\n\n    const node = attrs.allNodes.filter(({\n      data\n    }) => data.nodeId == id)[0]; // If node exists, set expansion flag\n\n    if (node) node.data.expanded = expandedFlag; // First expand all nodes\n\n    attrs.root.children.forEach(d => this.expand(d)); // Then collapse all nodes\n\n    attrs.root.children.forEach(d => this.collapse(d)); // Then expand only the nodes, which were previously expanded, or have an expand flag set\n\n    attrs.root.children.forEach(d => this.expandSomeNodes(d)); // Redraw graph\n\n    this.update(attrs.root);\n  } // Method which only expands nodes, which have property set \"expanded=true\"\n\n\n  expandSomeNodes(d) {\n    // If node has expanded property set\n    if (d.data.expanded) {\n      // Retrieve node's parent\n      let parent = d.parent; // While we can go up \n\n      while (parent) {\n        // Expand all current parent's children\n        if (parent._children) {\n          parent.children = parent._children;\n        } // Replace current parent holding object\n\n\n        parent = parent.parent;\n      }\n    } // Recursivelly do the same for collapsed nodes\n\n\n    if (d._children) {\n      d._children.forEach(ch => this.expandSomeNodes(ch));\n    } // Recursivelly do the same for expanded nodes \n\n\n    if (d.children) {\n      d.children.forEach(ch => this.expandSomeNodes(ch));\n    }\n  } // This function updates nodes state and redraws graph, usually after data change\n\n\n  updateNodesState() {\n    const attrs = this.getChartState(); // Store new root by converting flat data to hierarchy\n\n    attrs.root = d3.stratify().id(({\n      nodeId\n    }) => nodeId).parentId(({\n      parentNodeId\n    }) => parentNodeId)(attrs.data); // Store positions, where children appear during their enter animation\n\n    attrs.root.x0 = 0;\n    attrs.root.y0 = 0; // Store all nodes in flat format (although, now we can browse parent, see depth e.t.c. )\n\n    attrs.allNodes = attrs.layouts.treemap(attrs.root).descendants(); // Store direct and total descendants count\n\n    attrs.allNodes.forEach(d => {\n      Object.assign(d.data, {\n        directSubordinates: d.children ? d.children.length : 0,\n        totalSubordinates: d.descendants().length - 1\n      });\n    }); // Expand all nodes first\n\n    attrs.root.children && attrs.root.children.forEach(this.expand); // Then collapse them all\n\n    attrs.root.children && attrs.root.children.forEach(d => this.collapse(d)); // Then only expand nodes, which have expanded proprty set to true\n\n    attrs.root.children && attrs.root.children.forEach(ch => this.expandSomeNodes(ch)); // Redraw Graphs\n\n    this.update(attrs.root);\n  } // Function which collapses passed node and it's descendants\n\n\n  collapse(d) {\n    if (d.children) {\n      d._children = d.children;\n\n      d._children.forEach(ch => this.collapse(ch));\n\n      d.children = null;\n    }\n  } // Function which expands passed node and it's descendants \n\n\n  expand(d) {\n    if (d._children) {\n      d.children = d._children;\n      d.children.forEach(ch => this.expand(ch));\n      d._children = null;\n    }\n  } // Zoom handler function\n\n\n  zoomed() {\n    const attrs = this.getChartState();\n    const chart = attrs.chart; // Get d3 event's transform object\n\n    const transform = d3.event.transform; // Store it\n\n    attrs.lastTransform = transform; // Reposition and rescale chart accordingly\n\n    chart.attr('transform', transform); // Apply new styles to the foreign object element\n\n    if (this.isEdge()) {\n      this.restyleForeignObjectElements();\n    }\n  }\n\n}\n\nmodule.exports = TreeChart;","map":{"version":3,"sources":["/Users/derek/Desktop/org-chart/react/node_modules/d3-org-chart/index.js"],"names":["d3","require","TreeChart","constructor","attrs","id","Math","floor","random","svgWidth","svgHeight","marginTop","marginBottom","marginRight","marginLeft","container","defaultTextFill","nodeTextFill","defaultFont","backgroundColor","data","depth","duration","strokeWidth","dropShadowId","initialZoom","onNodeClick","d","getChartState","Object","keys","forEach","key","_","arguments","length","initializeEnterExitUpdatePattern","selection","prototype","patternify","params","selector","elementTag","tag","selectAll","i","exit","remove","enter","append","merge","attr","getNodeChildrenIds","children","_children","nodeIdsStore","push","nodeId","setZoomFactor","zoomLevel","calc","centerG","centerX","nodeMaxHeight","render","thisObjRef","select","containerRect","node","getBoundingClientRect","width","setDropShadowId","chartTopMargin","chartLeftMargin","chartWidth","chartHeight","nodeMaxWidth","max","height","layouts","treemap","tree","size","nodeSize","behaviors","zoom","on","zoomed","root","stratify","parentId","parentNodeId","x0","y0","allNodes","descendants","assign","directSubordinates","totalSubordinates","collapse","expandSomeNodes","svg","call","style","chart","defs","filterDefs","filter","feMerge","update","window","DOM","uid","addNode","obj","updateNodesState","removeNode","nodeChildrenIds","includes","bind","x","y","treeData","nodes","map","imageWidth","imageHeight","imageBorderColor","imageBorderWidth","imageRx","imageCenterTopDistance","imageCenterLeftDistance","borderColor","nodeImage","shadow","rgbaObjToColor","borderWidth","centerTopDistance","centerLeftDistance","cornerShape","toLowerCase","min","links","slice","patternsSelection","patternEnterSelection","patterns","patternImages","url","transition","linkSelection","linkEnter","insert","o","diagonal","linkUpdate","connectorLineWidth","connectorLineColor","dashArray","parent","linkExit","nodesSelection","nodeEnter","event","srcElement","classList","nodeImageGroups","nodeUpdate","fo","restyleForeignObjectElements","nodeButtonGroups","onButtonClick","borderRadius","text","isEdge","nodeExitTransition","navigator","userAgent","red","green","blue","alpha","s","t","ex","ey","xrvs","yrvs","rdef","rInitial","abs","r","h","w","path","html","template","setExpansionFlagToChildren","expanded","flag","setExpanded","expandedFlag","expand","ch","transform","lastTransform","module","exports"],"mappings":"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","sourcesContent":["d3 = require('d3');\n\nclass TreeChart {\n    constructor() {\n        // Exposed variables\n        const attrs = {\n            id: `ID${Math.floor(Math.random() * 1000000)}`, // Id for event handlings\n            svgWidth: 800,\n            svgHeight: 600,\n            marginTop: 0,\n            marginBottom: 0,\n            marginRight: 0,\n            marginLeft: 0,\n            container: 'body',\n            defaultTextFill: '#2C3E50',\n            nodeTextFill: 'white',\n            defaultFont: 'Helvetica',\n            backgroundColor: '#fafafa',\n            data: null,\n            depth: 180,\n            duration: 600,\n            strokeWidth: 3,\n            dropShadowId: null,\n            initialZoom: 1,\n            onNodeClick: d => d,\n        };\n\n        this.getChartState = () => attrs;\n\n        // Dynamically set getter and setter functions for Chart class\n        Object.keys(attrs).forEach((key) => {\n            //@ts-ignore\n            this[key] = function (_) {\n                if (!arguments.length) {\n                  return attrs[key];\n                } else {\n                  attrs[key] = _\n                }\n                return this;\n            };\n        });\n\n\n        this.initializeEnterExitUpdatePattern();\n    }\n\n    initializeEnterExitUpdatePattern() {\n        d3.selection.prototype.patternify = function (params) {\n            var container = this;\n            var selector = params.selector;\n            var elementTag = params.tag;\n            var data = params.data || [selector];\n\n            // Pattern in action\n            var selection = container.selectAll('.' + selector).data(data, (d, i) => {\n                if (typeof d === 'object') {\n                    if (d.id) {\n                        return d.id;\n                    }\n                }\n                return i;\n            });\n            selection.exit().remove();\n            selection = selection.enter().append(elementTag).merge(selection);\n            selection.attr('class', selector);\n            return selection;\n        };\n    }\n\n    // This method retrieves passed node's children IDs (including node)      \n    getNodeChildrenIds({\n        data,\n        children,\n        _children\n    }, nodeIdsStore) {\n\n        // Store current node ID\n        nodeIdsStore.push(data.nodeId);\n\n        // Loop over children and recursively store descendants id (expanded nodes)\n        if (children) {\n            children.forEach(d => {\n                this.getNodeChildrenIds(d, nodeIdsStore)\n            })\n        }\n\n        // Loop over _children and recursively store descendants id (collapsed nodes)\n        if (_children) {\n            _children.forEach(d => {\n                this.getNodeChildrenIds(d, nodeIdsStore)\n            })\n        }\n\n        // Return result\n        return nodeIdsStore;\n    }\n\n    // This method can be invoked via chart.setZoomFactor API, it zooms to particulat scale\n    setZoomFactor(zoomLevel) {\n        const attrs = this.getChartState();\n        const calc = attrs.calc;\n\n        // Store passed zoom level\n        attrs.initialZoom = zoomLevel;\n\n        // Rescale container element accordingly\n        attrs.centerG.attr('transform', ` translate(${calc.centerX}, ${calc.nodeMaxHeight / 2}) scale(${attrs.initialZoom})`)\n    }\n\n    render() {\n        //InnerFunctions which will update visuals\n\n        const attrs = this.getChartState();\n        const thisObjRef = this;\n\n        //Drawing containers\n        const container = d3.select(attrs.container);\n        const containerRect = container.node().getBoundingClientRect();\n        if (containerRect.width > 0) attrs.svgWidth = containerRect.width;\n\n        //Attach drop shadow id to attrs object\n        this.setDropShadowId(attrs);\n\n        //Calculated properties\n        const calc = {\n            id: null,\n            chartTopMargin: null,\n            chartLeftMargin: null,\n            chartWidth: null,\n            chartHeight: null\n        };\n        calc.id = `ID${Math.floor(Math.random() * 1000000)}`; // id for event handlings\n        calc.chartLeftMargin = attrs.marginLeft;\n        calc.chartTopMargin = attrs.marginTop;\n        calc.chartWidth = attrs.svgWidth - attrs.marginRight - calc.chartLeftMargin;\n        calc.chartHeight = attrs.svgHeight - attrs.marginBottom - calc.chartTopMargin;\n        attrs.calc = calc;\n\n        // Get maximum node width and height\n        calc.nodeMaxWidth = d3.max(attrs.data, ({\n            width\n        }) => width);\n        calc.nodeMaxHeight = d3.max(attrs.data, ({\n            height\n        }) => height);\n\n        // Calculate max node depth (it's needed for layout heights calculation)\n        attrs.depth = calc.nodeMaxHeight + 100;\n        calc.centerX = calc.chartWidth / 2;\n\n        //********************  LAYOUTS  ***********************\n        const layouts = {\n            treemap: null\n        }\n        attrs.layouts = layouts;\n\n        // Generate tree layout function\n        layouts.treemap = d3.tree().size([calc.chartWidth, calc.chartHeight])\n            .nodeSize([calc.nodeMaxWidth + 100, calc.nodeMaxHeight + attrs.depth])\n\n        // ******************* BEHAVIORS . **********************\n        const behaviors = {\n            zoom: null\n        }\n\n        // Get zooming function \n        behaviors.zoom = d3.zoom().on(\"zoom\", d => this.zoomed(d))\n\n        //****************** ROOT node work ************************\n\n        // Convert flat data to hierarchical\n        attrs.root = d3.stratify()\n            .id(({\n                nodeId\n            }) => nodeId)\n            .parentId(({\n                parentNodeId\n            }) => parentNodeId)\n            (attrs.data)\n\n        // Set child nodes enter appearance positions\n        attrs.root.x0 = 0;\n        attrs.root.y0 = 0;\n\n        /** Get all nodes as array (with extended parent & children properties set)\n            This way we can access any node's parent directly using node.parent - pretty cool, huh?\n        */\n        attrs.allNodes = attrs.layouts.treemap(attrs.root).descendants()\n\n        // Assign direct children and total subordinate children's cound\n        attrs.allNodes.forEach(d => {\n            Object.assign(d.data, {\n                directSubordinates: d.children ? d.children.length : 0,\n                totalSubordinates: d.descendants().length - 1\n            })\n        })\n\n        const children = attrs.root.children;\n\n        if(children) {\n            // Collapse all children at first\n            children.forEach(d => this.collapse(d));\n\n            // Then expand some nodes, which have `expanded` property set\n            children.forEach(d => this.expandSomeNodes(d));\n        }\n        \n\n        // *************************  DRAWING **************************\n        //Add svg\n        const svg = container\n            .patternify({\n                tag: 'svg',\n                selector: 'svg-chart-container'\n            })\n            .attr('width', attrs.svgWidth)\n            .attr('height', attrs.svgHeight)\n            .attr('font-family', attrs.defaultFont)\n            .call(behaviors.zoom)\n            .attr('cursor', 'move')\n            .style('background-color', attrs.backgroundColor);\n        attrs.svg = svg;\n\n        //Add container g element\n        const chart = svg\n            .patternify({\n                tag: 'g',\n                selector: 'chart'\n            })\n            .attr('transform', `translate(${calc.chartLeftMargin},${calc.chartTopMargin})`);\n\n        // Add one more container g element, for better positioning controls\n        attrs.centerG = chart.patternify({\n            tag: 'g',\n            selector: 'center-group'\n        })\n            .attr('transform', `translate(${calc.centerX},${calc.nodeMaxHeight / 2}) scale(${attrs.initialZoom})`);\n\n        attrs.chart = chart;\n\n        // ************************** ROUNDED AND SHADOW IMAGE  WORK USING SVG FILTERS **********************\n\n        //Adding defs element for rounded image\n        attrs.defs = svg.patternify({\n            tag: 'defs',\n            selector: 'image-defs'\n        });\n\n        // Adding defs element for image's shadow\n        const filterDefs = svg.patternify({\n            tag: 'defs',\n            selector: 'filter-defs'\n        });\n\n        // Adding shadow element - (play with svg filter here - https://bit.ly/2HwnfyL)\n        const filter = filterDefs.patternify({\n            tag: 'filter',\n            selector: 'shadow-filter-element'\n        })\n            .attr('id', attrs.dropShadowId)\n            .attr('y', `${-50}%`)\n            .attr('x', `${-50}%`)\n            .attr('height', `${200}%`)\n            .attr('width', `${200}%`);\n\n        // Add gaussian blur element for shadows - we can control shadow length with this\n        filter.patternify({\n            tag: 'feGaussianBlur',\n            selector: 'feGaussianBlur-element'\n        })\n            .attr('in', 'SourceAlpha')\n            .attr('stdDeviation', 3.1)\n            .attr('result', 'blur');\n\n        // Add fe-offset element for shadows -  we can control shadow positions with it\n        filter.patternify({\n            tag: 'feOffset',\n            selector: 'feOffset-element'\n        })\n            .attr('in', 'blur')\n            .attr('result', 'offsetBlur')\n            .attr(\"dx\", 4.28)\n            .attr(\"dy\", 4.48)\n            .attr(\"x\", 8)\n            .attr(\"y\", 8)\n\n        // Add fe-flood element for shadows - we can control shadow color and opacity with this element\n        filter.patternify({\n            tag: 'feFlood',\n            selector: 'feFlood-element'\n        })\n            .attr(\"in\", \"offsetBlur\")\n            .attr(\"flood-color\", 'black')\n            .attr(\"flood-opacity\", 0.3)\n            .attr(\"result\", \"offsetColor\");\n\n        // Add feComposite element for shadows\n        filter.patternify({\n            tag: 'feComposite',\n            selector: 'feComposite-element'\n        })\n            .attr(\"in\", \"offsetColor\")\n            .attr(\"in2\", \"offsetBlur\")\n            .attr(\"operator\", \"in\")\n            .attr(\"result\", \"offsetBlur\");\n\n        // Add feMerge element for shadows\n        const feMerge = filter.patternify({\n            tag: 'feMerge',\n            selector: 'feMerge-element'\n        });\n\n        // Add feMergeNode element for shadows\n        feMerge.patternify({\n            tag: 'feMergeNode',\n            selector: 'feMergeNode-blur'\n        })\n            .attr('in', 'offsetBlur')\n\n        // Add another feMergeNode element for shadows\n        feMerge.patternify({\n            tag: 'feMergeNode',\n            selector: 'feMergeNode-graphic'\n        })\n            .attr('in', 'SourceGraphic')\n\n        // Display tree contenrs\n        this.update(attrs.root)\n\n\n\n        //#########################################  UTIL FUNCS ##################################\n        // This function restyles foreign object elements ()\n\n\n\n\n        d3.select(window).on(`resize.${attrs.id}`, () => {\n            const containerRect = container.node().getBoundingClientRect();\n            //  if (containerRect.width > 0) attrs.svgWidth = containerRect.width;\n            //\tmain();\n        });\n\n\n        return this;\n    }\n\n    // This function sets drop shadow ID to the passed object\n    setDropShadowId(d) {\n\n        // If it's already set, then return \n        if (d.dropShadowId) return;\n\n        // Generate drop shadow ID\n        let id = `${d.id}-drop-shadow`;\n\n        // If DOM object is available, then use UID method to generated shadow id\n        //@ts-ignore\n        if (typeof DOM != 'undefined') {\n            //@ts-ignore\n            id = DOM.uid(d.id).id;\n        }\n\n        // Extend passed object with drop shadow ID\n        Object.assign(d, {\n            dropShadowId: id\n        })\n    }\n\n\n    // This function can be invoked via chart.addNode API, and it adds node in tree at runtime\n    addNode(obj) {\n        const attrs = this.getChartState();\n        attrs.data.push(obj);\n\n        // Update state of nodes and redraw graph\n        this.updateNodesState();\n        return this;\n    }\n\n    // This function can be invoked via chart.removeNode API, and it removes node from tree at runtime\n    removeNode(nodeId) {\n        const attrs = this.getChartState();\n        const node = attrs.allNodes.filter(({\n            data\n        }) => data.nodeId == nodeId)[0];\n\n\n        // Remove all node childs\n        if (node) {\n            // Retrieve all children nodes ids (including current node itself)\n            const nodeChildrenIds = this.getNodeChildrenIds(node, []);\n\n            // Filter out retrieved nodes and reassign data\n            attrs.data = attrs.data.filter(d => !nodeChildrenIds.includes(d.nodeId))\n\n            const updateNodesState = this.updateNodesState.bind(this);\n            // Update state of nodes and redraw graph\n            updateNodesState();\n        }\n    }\n\n    // This function basically redraws visible graph, based on nodes state\n    update({\n        x0,\n        y0,\n        x,\n        y\n    }) {\n\n        const attrs = this.getChartState();\n        const calc = attrs.calc;\n\n        //  Assigns the x and y position for the nodes\n        const treeData = attrs.layouts.treemap(attrs.root);\n\n        // Get tree nodes and links and attach some properties \n        const nodes = treeData.descendants()\n            .map(d => {\n                // If at least one property is already set, then we don't want to reset other properties\n                if (d.width) return d;\n\n                // Declare properties with deffault values\n                let imageWidth = 100;\n                let imageHeight = 100;\n                let imageBorderColor = 'steelblue';\n                let imageBorderWidth = 0;\n                let imageRx = 0;\n                let imageCenterTopDistance = 0;\n                let imageCenterLeftDistance = 0;\n                let borderColor = 'steelblue';\n                let backgroundColor = 'steelblue';\n                let width = d.data.width;\n                let height = d.data.height;\n                let dropShadowId = `none`;\n\n                // Override default values based on data\n                if (d.data.nodeImage && d.data.nodeImage.shadow) {\n                    dropShadowId = `url(#${attrs.dropShadowId})`\n                }\n                if (d.data.nodeImage && d.data.nodeImage.width) {\n                    imageWidth = d.data.nodeImage.width\n                };\n                if (d.data.nodeImage && d.data.nodeImage.height) {\n                    imageHeight = d.data.nodeImage.height\n                };\n                if (d.data.nodeImage && d.data.nodeImage.borderColor) {\n                    imageBorderColor = this.rgbaObjToColor(d.data.nodeImage.borderColor)\n                };\n                if (d.data.nodeImage && d.data.nodeImage.borderWidth) {\n                    imageBorderWidth = d.data.nodeImage.borderWidth\n                };\n                if (d.data.nodeImage && d.data.nodeImage.centerTopDistance) {\n                    imageCenterTopDistance = d.data.nodeImage.centerTopDistance\n                };\n                if (d.data.nodeImage && d.data.nodeImage.centerLeftDistance) {\n                    imageCenterLeftDistance = d.data.nodeImage.centerLeftDistance\n                };\n                if (d.data.borderColor) {\n                    borderColor = this.rgbaObjToColor(d.data.borderColor);\n                }\n                if (d.data.backgroundColor) {\n                    backgroundColor = this.rgbaObjToColor(d.data.backgroundColor);\n                }\n                if (d.data.nodeImage &&\n                    d.data.nodeImage.cornerShape.toLowerCase() == \"circle\") {\n                    imageRx = Math.max(imageWidth, imageHeight);\n                }\n                if (d.data.nodeImage &&\n                    d.data.nodeImage.cornerShape.toLowerCase() == \"rounded\") {\n                    imageRx = Math.min(imageWidth, imageHeight) / 6;\n                }\n\n                // Extend node object with calculated properties\n                return Object.assign(d, {\n                    imageWidth,\n                    imageHeight,\n                    imageBorderColor,\n                    imageBorderWidth,\n                    borderColor,\n                    backgroundColor,\n                    imageRx,\n                    width,\n                    height,\n                    imageCenterTopDistance,\n                    imageCenterLeftDistance,\n                    dropShadowId\n                });\n            });\n\n        // Get all links\n        const links = treeData.descendants().slice(1);\n\n        // Set constant depth for each nodes\n        nodes.forEach(d => d.y = d.depth * attrs.depth);\n\n        // ------------------- FILTERS ---------------------\n\n        // Add patterns for each node (it's needed for rounded image implementation)\n        const patternsSelection = attrs.defs.selectAll('.pattern')\n            .data(nodes, ({\n                id\n            }) => id);\n\n        // Define patterns enter selection\n        const patternEnterSelection = patternsSelection.enter().append('pattern')\n\n        // Patters update selection\n        const patterns = patternEnterSelection\n            .merge(patternsSelection)\n            .attr('class', 'pattern')\n            .attr('height', 1)\n            .attr('width', 1)\n            .attr('id', ({\n                id\n            }) => id)\n\n        // Add images to patterns\n        const patternImages = patterns.patternify({\n            tag: 'image',\n            selector: 'pattern-image',\n            data: d => [d]\n        })\n            .attr('x', 0)\n            .attr('y', 0)\n            .attr('height', ({\n                imageWidth\n            }) => imageWidth)\n            .attr('width', ({\n                imageHeight\n            }) => imageHeight)\n            .attr('xlink:href', ({\n                data\n            }) => data.nodeImage && data.nodeImage.url)\n            .attr('viewbox', ({\n                imageWidth,\n                imageHeight\n            }) => `0 0 ${imageWidth * 2} ${imageHeight}`)\n            .attr('preserveAspectRatio', 'xMidYMin slice')\n\n        // Remove patterns exit selection after animation\n        patternsSelection.exit().transition().duration(attrs.duration).remove();\n\n        // --------------------------  LINKS ----------------------\n        // Get links selection\n        const linkSelection = attrs.centerG.selectAll('path.link')\n            .data(links, ({\n                id\n            }) => id);\n\n        // Enter any new links at the parent's previous position.\n        const linkEnter = linkSelection.enter()\n            .insert('path', \"g\")\n            .attr(\"class\", \"link\")\n            .attr('d', d => {\n                const o = {\n                    x: x0,\n                    y: y0\n                };\n                return this.diagonal(o, o)\n            });\n\n        // Get links update selection\n        const linkUpdate = linkEnter.merge(linkSelection);\n\n        // Styling links\n        linkUpdate\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke-width\", ({\n                data\n            }) => data.connectorLineWidth || 2)\n            .attr('stroke', ({\n                data\n            }) => {\n                if (data.connectorLineColor) {\n                    return this.rgbaObjToColor(data.connectorLineColor);\n                }\n                return 'green';\n            })\n            .attr('stroke-dasharray', ({\n                data\n            }) => {\n                if (data.dashArray) {\n                    return data.dashArray;\n                }\n                return '';\n            })\n\n        // Transition back to the parent element position\n        linkUpdate.transition()\n            .duration(attrs.duration)\n            .attr('d', d => this.diagonal(d, d.parent));\n\n        // Remove any  links which is exiting after animation\n        const linkExit = linkSelection.exit().transition()\n            .duration(attrs.duration)\n            .attr('d', d => {\n                const o = {\n                    x: x,\n                    y: y\n                };\n                return this.diagonal(o, o)\n            })\n            .remove();\n\n        // --------------------------  NODES ----------------------\n        // Get nodes selection\n        const nodesSelection = attrs.centerG.selectAll('g.node')\n            .data(nodes, ({\n                id\n            }) => id)\n\n        // Enter any new nodes at the parent's previous position.\n        const nodeEnter = nodesSelection.enter().append('g')\n            .attr('class', 'node')\n            .attr(\"transform\", d => `translate(${x0},${y0})`)\n            .attr('cursor', 'pointer')\n            .on('click', ({\n                data\n            }) => {\n                if ([...d3.event.srcElement.classList].includes('node-button-circle')) {\n                    return;\n                }\n                attrs.onNodeClick(data.nodeId);\n            });\n\n        // Add background rectangle for the nodes \n        nodeEnter\n            .patternify({\n                tag: 'rect',\n                selector: 'node-rect',\n                data: d => [d]\n            })\n            .style(\"fill\", ({\n                _children\n            }) => _children ? \"lightsteelblue\" : \"#fff\")\n\n\n        /*\n        // Add node icon image inside node\n        nodeEnter\n            .patternify({\n                tag: 'image',\n                selector: 'node-icon-image',\n                data: d => [d]\n            })\n            .attr('width', ({\n                data\n            }) => data.nodeIcon && data.nodeIcon.size)\n            .attr('height', ({\n                data\n            }) => data.nodeIcon && data.nodeIcon.size)\n            .attr(\"xlink:href\", ({\n                data\n            }) => data.nodeIcon && data.nodeIcon.icon)\n            .attr('x', ({\n                width\n            }) => -width / 2 + 5)\n            .attr('y', ({\n                height,\n                data\n            }) => height / 2 - (data.nodeIcon && data.nodeIcon.size || 0) - 5)\n\n        // Add total descendants text\n        nodeEnter\n            .patternify({\n                tag: 'text',\n                selector: 'node-icon-text-total',\n                data: d => [d]\n            })\n            .text('test')\n            .attr('x', ({\n                width\n            }) => -width / 2 + 7)\n            .attr('y', ({\n                height,\n                data\n            }) => height / 2 -  (data.nodeIcon && data.nodeIcon.size) - 5)\n            .text(({\n                data\n            }) => `${data.totalSubordinates} Subordinates`)\n            .attr('fill', attrs.nodeTextFill)\n            .attr('font-weight', 'bold')\n\n        // Add direct descendants text\n        nodeEnter\n            .patternify({\n                tag: 'text',\n                selector: 'node-icon-text-direct',\n                data: d => [d]\n            })\n            .text('test')\n            .attr('x', ({\n                width,\n                data\n            }) => -width / 2 + 10 + (data.nodeIcon && data.nodeIcon.size))\n            .attr('y', ({\n                height\n            }) => height / 2 - 10)\n            .text(({\n                data\n            }) => `${data.directSubordinates} Direct `)\n            .attr('fill', attrs.nodeTextFill)\n            .attr('font-weight', 'bold')\n          */\n\n\n        // Defined node images wrapper group\n        const nodeImageGroups = nodeEnter.patternify({\n            tag: 'g',\n            selector: 'node-image-group',\n            data: d => [d]\n        })\n\n        // Add background rectangle for node image\n        nodeImageGroups\n            .patternify({\n                tag: 'rect',\n                selector: 'node-image-rect',\n                data: d => [d]\n            })\n\n\n\n        // Node update styles\n        const nodeUpdate = nodeEnter.merge(nodesSelection)\n            .style('font', '12px sans-serif');\n\n\n\n        // Add foreignObject element inside rectangle\n        const fo = nodeUpdate\n            .patternify({\n                tag: 'foreignObject',\n                selector: 'node-foreign-object',\n                data: d => [d]\n            })\n\n\n        // Add foreign object \n        fo.patternify({\n            tag: 'xhtml:div',\n            selector: 'node-foreign-object-div',\n            data: d => [d]\n        })\n\n        this.restyleForeignObjectElements();\n\n\n\n        // Add Node button circle's group (expand-collapse button)\n        const nodeButtonGroups = nodeEnter\n            .patternify({\n                tag: 'g',\n                selector: 'node-button-g',\n                data: d => [d]\n            })\n            .on('click', d => this.onButtonClick(d))\n\n        // Add expand collapse button circle \n        nodeButtonGroups\n            .patternify({\n                tag: 'circle',\n                selector: 'node-button-circle',\n                data: d => [d]\n            })\n\n        // Add button text \n        nodeButtonGroups\n            .patternify({\n                tag: 'text',\n                selector: 'node-button-text',\n                data: d => [d]\n            })\n            .attr('pointer-events', 'none')\n\n        // Transition to the proper position for the node\n        nodeUpdate.transition()\n            .attr('opacity', 0)\n            .duration(attrs.duration)\n            .attr(\"transform\", ({\n                x,\n                y\n            }) => `translate(${x},${y})`)\n            .attr('opacity', 1)\n\n        // Move images to desired positions\n        nodeUpdate.selectAll('.node-image-group')\n            .attr('transform', ({\n                imageWidth,\n                width,\n                imageHeight,\n                height\n            }) => {\n                let x = -imageWidth / 2 - width / 2;\n                let y = -imageHeight / 2 - height / 2;\n                return `translate(${x},${y})`\n            })\n\n        // Style node image rectangles\n        nodeUpdate.select('.node-image-rect')\n            .attr('fill', ({\n                id\n            }) => `url(#${id})`)\n            .attr('width', ({\n                imageWidth\n            }) => imageWidth)\n            .attr('height', ({\n                imageHeight\n            }) => imageHeight)\n            .attr('stroke', ({\n                imageBorderColor\n            }) => imageBorderColor)\n            .attr('stroke-width', ({\n                imageBorderWidth\n            }) => imageBorderWidth)\n            .attr('rx', ({\n                imageRx\n            }) => imageRx)\n            .attr('y', ({\n                imageCenterTopDistance\n            }) => imageCenterTopDistance)\n            .attr('x', ({\n                imageCenterLeftDistance\n            }) => imageCenterLeftDistance)\n            .attr('filter', ({\n                dropShadowId\n            }) => dropShadowId)\n\n        // Style node rectangles\n        nodeUpdate.select('.node-rect')\n            .attr('width', ({\n                data\n            }) => data.width)\n            .attr('height', ({\n                data\n            }) => data.height)\n            .attr('x', ({\n                data\n            }) => -data.width / 2)\n            .attr('y', ({\n                data\n            }) => -data.height / 2)\n            .attr('rx', ({\n                data\n            }) => data.borderRadius || 0)\n            .attr('stroke-width', ({\n                data\n            }) => data.borderWidth || attrs.strokeWidth)\n            .attr('cursor', 'pointer')\n            .attr('stroke', ({\n                borderColor\n            }) => borderColor)\n            .style(\"fill\", ({\n                backgroundColor\n            }) => backgroundColor)\n\n        // Move node button group to the desired position\n        nodeUpdate.select('.node-button-g')\n            .attr('transform', ({\n                data\n            }) => `translate(0,${data.height / 2})`)\n            .attr('opacity', ({\n                children,\n                _children\n            }) => {\n                if (children || _children) {\n                    return 1;\n                }\n                return 0;\n            })\n\n        // Restyle node button circle\n        nodeUpdate.select('.node-button-circle')\n            .attr('r', 16)\n            .attr('stroke-width', ({\n                data\n            }) => data.borderWidth || attrs.strokeWidth)\n            .attr('fill', attrs.backgroundColor)\n            .attr('stroke', ({\n                borderColor\n            }) => borderColor)\n\n        // Restyle button texts\n        nodeUpdate.select('.node-button-text')\n            .attr('text-anchor', 'middle')\n            .attr('alignment-baseline', 'middle')\n            .attr('fill', attrs.defaultTextFill)\n            .attr('font-size', ({\n                children\n            }) => {\n                if (children) return 40;\n                return 26;\n            })\n            .text(({\n                children\n            }) => {\n                if (children) return '-';\n                return '+';\n            })\n            .attr('y', this.isEdge() ? 10 : 0)\n\n        // Remove any exiting nodes after transition\n        const nodeExitTransition = nodesSelection.exit()\n            .attr('opacity', 1)\n            .transition()\n            .duration(attrs.duration)\n            .attr(\"transform\", d => `translate(${x},${y})`)\n            .on('end', function () {\n                d3.select(this).remove();\n            })\n            .attr('opacity', 0);\n\n        // On exit reduce the node rects size to 0\n        nodeExitTransition.selectAll('.node-rect')\n            .attr('width', 10)\n            .attr('height', 10)\n            .attr('x', 0)\n            .attr('y', 0);\n\n        // On exit reduce the node image rects size to 0\n        nodeExitTransition.selectAll('.node-image-rect')\n            .attr('width', 10)\n            .attr('height', 10)\n            .attr('x', ({\n                width\n            }) => width / 2)\n            .attr('y', ({\n                height\n            }) => height / 2)\n\n        // Store the old positions for transition.\n        nodes.forEach(d => {\n            d.x0 = d.x;\n            d.y0 = d.y;\n        });\n    }\n\n    // This function detects whether current browser is edge\n    isEdge() {\n        return window.navigator.userAgent.includes(\"Edge\");\n    }\n\n    /* Function converts rgba objects to rgba color string \n      {red:110,green:150,blue:255,alpha:1}  => rgba(110,150,255,1)\n    */\n    rgbaObjToColor({\n        red,\n        green,\n        blue,\n        alpha\n    }) {\n        return `rgba(${red},${green},${blue},${alpha})`;\n    }\n\n    // Generate custom diagonal - play with it here - https://observablehq.com/@bumbeishvili/curved-edges?collection=@bumbeishvili/work-components\n    diagonal(s, t) {\n\n        // Calculate some variables based on source and target (s,t) coordinates\n        const x = s.x;\n        const y = s.y;\n        const ex = t.x;\n        const ey = t.y;\n        let xrvs = ex - x < 0 ? -1 : 1;\n        let yrvs = ey - y < 0 ? -1 : 1;\n        let rdef = 35;\n        let rInitial = Math.abs(ex - x) / 2 < rdef ? Math.abs(ex - x) / 2 : rdef;\n        let r = Math.abs(ey - y) / 2 < rInitial ? Math.abs(ey - y) / 2 : rInitial;\n        let h = Math.abs(ey - y) / 2 - r;\n        let w = Math.abs(ex - x) - r * 2;\n\n        // Build the path\n        const path = `\n             M ${x} ${y}\n             L ${x} ${y + h * yrvs}\n             C  ${x} ${y + h * yrvs + r * yrvs} ${x} ${y + h * yrvs + r * yrvs} ${x + r * xrvs} ${y + h * yrvs + r * yrvs}\n             L ${x + w * xrvs + r * xrvs} ${y + h * yrvs + r * yrvs}\n             C ${ex}  ${y + h * yrvs + r * yrvs} ${ex}  ${y + h * yrvs + r * yrvs} ${ex} ${ey - h * yrvs}\n             L ${ex} ${ey}\n           `\n        // Return result\n        return path;\n    }\n\n    restyleForeignObjectElements() {\n        const attrs = this.getChartState();\n\n        attrs.svg.selectAll('.node-foreign-object')\n            .attr('width', ({\n                width\n            }) => width)\n            .attr('height', ({\n                height\n            }) => height)\n            .attr('x', ({\n                width\n            }) => -width / 2)\n            .attr('y', ({\n                height\n            }) => -height / 2)\n        attrs.svg.selectAll('.node-foreign-object-div')\n            .style('width', ({\n                width\n            }) => `${width}px`)\n            .style('height', ({\n                height\n            }) => `${height}px`)\n            .style('color', 'white')\n            .html(({\n                data\n            }) => data.template)\n    }\n\n    // Toggle children on click.\n    onButtonClick(d) {\n\n        // If childrens are expanded\n        if (d.children) {\n\n            //Collapse them\n            d._children = d.children;\n            d.children = null;\n\n            // Set descendants expanded property to false\n            this.setExpansionFlagToChildren(d, false);\n        } else {\n\n            // Expand children\n            d.children = d._children;\n            d._children = null;\n\n            // Set each children as expanded\n            d.children.forEach(({\n                data\n            }) => data.expanded = true)\n        }\n\n        // Redraw Graph \n        this.update(d);\n    }\n\n    // This function changes `expanded` property to descendants\n    setExpansionFlagToChildren({\n        data,\n        children,\n        _children\n    }, flag) {\n\n        // Set flag to the current property\n        data.expanded = flag;\n\n        // Loop over and recursively update expanded children's descendants\n        if (children) {\n            children.forEach(d => {\n                this.setExpansionFlagToChildren(d, flag)\n            })\n        }\n\n        // Loop over and recursively update collapsed children's descendants\n        if (_children) {\n            _children.forEach(d => {\n                this.setExpansionFlagToChildren(d, flag)\n            })\n        }\n    }\n\n    // This function can be invoked via chart.setExpanded API, it expands or collapses particular node\n    setExpanded(id, expandedFlag) {\n        const attrs = this.getChartState();\n        // Retrieve node by node Id\n        const node = attrs.allNodes.filter(({\n            data\n        }) => data.nodeId == id)[0]\n\n        // If node exists, set expansion flag\n        if (node) node.data.expanded = expandedFlag;\n\n        // First expand all nodes\n        attrs.root.children.forEach(d => this.expand(d));\n\n        // Then collapse all nodes\n        attrs.root.children.forEach(d => this.collapse(d));\n\n        // Then expand only the nodes, which were previously expanded, or have an expand flag set\n        attrs.root.children.forEach(d => this.expandSomeNodes(d));\n\n        // Redraw graph\n        this.update(attrs.root);\n    }\n\n    // Method which only expands nodes, which have property set \"expanded=true\"\n    expandSomeNodes(d) {\n\n        // If node has expanded property set\n        if (d.data.expanded) {\n\n            // Retrieve node's parent\n            let parent = d.parent;\n\n            // While we can go up \n            while (parent) {\n\n                // Expand all current parent's children\n                if (parent._children) {\n                    parent.children = parent._children;\n                }\n\n                // Replace current parent holding object\n                parent = parent.parent;\n            }\n        }\n\n        // Recursivelly do the same for collapsed nodes\n        if (d._children) {\n            d._children.forEach(ch => this.expandSomeNodes(ch));\n        }\n\n        // Recursivelly do the same for expanded nodes \n        if (d.children) {\n            d.children.forEach(ch => this.expandSomeNodes(ch));\n        }\n    }\n\n\n    // This function updates nodes state and redraws graph, usually after data change\n    updateNodesState() {\n        const attrs = this.getChartState();\n        // Store new root by converting flat data to hierarchy\n        attrs.root = d3.stratify()\n            .id(({\n                nodeId\n            }) => nodeId)\n            .parentId(({\n                parentNodeId\n            }) => parentNodeId)\n            (attrs.data)\n\n        // Store positions, where children appear during their enter animation\n        attrs.root.x0 = 0;\n        attrs.root.y0 = 0;\n\n        // Store all nodes in flat format (although, now we can browse parent, see depth e.t.c. )\n        attrs.allNodes = attrs.layouts.treemap(attrs.root).descendants()\n\n        // Store direct and total descendants count\n        attrs.allNodes.forEach(d => {\n            Object.assign(d.data, {\n                directSubordinates: d.children ? d.children.length : 0,\n                totalSubordinates: d.descendants().length - 1\n            })\n        })\n\n        // Expand all nodes first\n        attrs.root.children && attrs.root.children.forEach(this.expand);\n\n        // Then collapse them all\n        attrs.root.children && attrs.root.children.forEach(d => this.collapse(d));\n\n        // Then only expand nodes, which have expanded proprty set to true\n        attrs.root.children && attrs.root.children.forEach(ch => this.expandSomeNodes(ch));\n\n        // Redraw Graphs\n        this.update(attrs.root)\n    }\n\n\n    // Function which collapses passed node and it's descendants\n    collapse(d) {\n        if (d.children) {\n            d._children = d.children;\n            d._children.forEach(ch => this.collapse(ch));\n            d.children = null;\n        }\n    }\n\n    // Function which expands passed node and it's descendants \n    expand(d) {\n        if (d._children) {\n            d.children = d._children;\n            d.children.forEach(ch => this.expand(ch));\n            d._children = null;\n        }\n    }\n\n    // Zoom handler function\n    zoomed() {\n        const attrs = this.getChartState();\n        const chart = attrs.chart;\n\n        // Get d3 event's transform object\n        const transform = d3.event.transform;\n\n        // Store it\n        attrs.lastTransform = transform;\n\n        // Reposition and rescale chart accordingly\n        chart.attr('transform', transform);\n\n        // Apply new styles to the foreign object element\n        if (this.isEdge()) {\n            this.restyleForeignObjectElements();\n        }\n\n    }\n\n}\n\n \nmodule.exports = TreeChart;\n"]},"metadata":{},"sourceType":"script"}